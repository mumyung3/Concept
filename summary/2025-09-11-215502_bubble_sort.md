# 버블 정렬과 C++ 메모리 개념 정리

## 주요 토픽
- 버블 정렬 알고리즘 구현 (배열, vector, list)
- 배열-포인터 decay 개념
- swapped 변수 최적화
- vector 내부 구조와 복사 메커니즘
- 공간복잡도 개념

## 1. 버블 정렬 구현

### 기본 알고리즘
- **시간복잡도**: O(n²), 최적화 시 O(n)
- **공간복잡도**: O(1) - in-place 정렬
- **핵심**: 인접한 원소들을 비교하여 교환

### 구현 방식별 특징

**배열 방식:**
```cpp
void bubbleSortArray(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) break;  // 최적화
    }
}
```

**Vector 방식:**
- 참조(`&`) 필수: 원본 수정을 위해
- 인덱스 접근 가능: `arr[j]`
- 동적 크기 조정 가능

**List 방식:**
- Iterator 기반: `auto current = lst.begin()`
- 순차 접근만 가능: 랜덤 액세스 불가
- 범위 최적화 어려움 (매번 전체 순회)

## 2. 배열-포인터 Decay

### 핵심 개념
```cpp
void func(int arr[]);     // 실제로는 int* arr
void func(int arr[5]);    // 여전히 int* arr  
void func(int* arr);      // 동일한 시그니처
```

### Decay 이유
1. **값 전달 방식**: C/C++의 기본 호출 메커니즘
2. **효율성**: 배열 전체 복사는 비용이 큼
3. **언어 설계**: 배열명 = 첫 번째 원소의 주소

### 해결책 (C++)
```cpp
void func(int (&arr)[5]);        // 참조로 고정 크기 유지
template<size_t N>
void func(int (&arr)[N]);        // 템플릿으로 크기 보존
```

## 3. swapped 변수 최적화

### 역할
- 한 패스에서 교환 발생 여부 확인
- 교환이 없으면 정렬 완료로 판단하여 조기 종료

### 성능 향상
- **일반적인 경우**: O(n²) → 변화 없음
- **이미 정렬된 경우**: O(n²) → O(n)

### 구현
```cpp
bool swapped = false;
// 내부 루프에서
if (arr[j] > arr[j + 1]) {
    swap(arr[j], arr[j + 1]);
    swapped = true;
}
// 외부 루프에서
if (!swapped) break;
```

## 4. Vector 내부 구조

### 주요 멤버 필드
```cpp
template<typename T>
class vector {
private:
    T* data;           // 실제 데이터 포인터
    size_t size_;      // 현재 원소 개수
    size_t capacity_;  // 할당된 메모리 크기
};
```

### 메모리 구조
```
vector 객체 (스택):        힙 메모리:
┌─────────────┐         [1][2][3][4][5][ ][ ][ ]
│ data ───────┼────────→  실제 데이터 저장소
│ size_ = 5   │
│ capacity_=8 │
└─────────────┘
```

## 5. Vector 복사 메커니즘

### Deep Copy 발생 시점
1. **복사 생성자**: `vector<int> v2 = v1;`
2. **대입 연산자**: `v2 = v1;`
3. **함수 매개변수**: `func(vector<int> arr)`

### 복사 과정
```cpp
// 복사 생성자 동작
vector(const vector& other) {
    size_ = other.size_;
    capacity_ = other.capacity_;
    data = new T[capacity_];        // 새 메모리 할당
    for (size_t i = 0; i < size_; i++) {
        data[i] = other.data[i];    // 원소별 복사
    }
}
```

### 결과
- 완전히 독립적인 복사본 생성
- 한 쪽 수정이 다른 쪽에 영향 없음
- 그래서 정렬 함수에는 참조(`&`) 필요

## 6. 공간복잡도 개념

### O(1) 공간복잡도
- 입력 크기와 무관하게 일정한 메모리 사용
- 버블정렬: `swapped`, `i`, `j` 등 몇 개 변수만 사용
- **In-place 알고리즘**의 특징

### 비교
- **O(1)**: 상수 개의 추가 변수
- **O(n)**: 입력 크기만큼 추가 메모리
- **O(n²)**: 입력 크기의 제곱만큼 메모리

## 7. 구현된 파일들

- `bubble_sort.cpp`: 배열과 vector 버전 구현
- `bubble_sort_list.cpp`: std::list 버전 구현
- 모든 파일에서 swapped 최적화 적용

## 중요한 인사이트

1. **배열 vs 리스트**: 배열이 인덱스 접근으로 더 효율적
2. **참조의 중요성**: 원본 수정을 위해서는 참조 필수
3. **Vector의 복사**: Deep copy로 인한 성능 비용 주의
4. **최적화**: swapped 변수로 조기 종료 가능
5. **메모리 모델**: 스택/힙 구조 이해 중요

## 추가 학습 방향

- 다른 정렬 알고리즘 비교 (퀵정렬, 머지정렬)
- Move semantics와 복사 최적화
- 템플릿을 이용한 제네릭 정렬 함수
- STL sort() 내부 구현 분석