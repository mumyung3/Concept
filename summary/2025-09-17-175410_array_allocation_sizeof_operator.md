# Array Allocation Performance & sizeof Operator

## 메모리 할당 성능 차이

### 정적 배열 (스택) - 1~2 CPU 사이클
```cpp
int arr[100];  // 컴파일 타임 크기 결정
```

**특징:**
- **스택 포인터 조정**: 단순히 SP를 400바이트만큼 이동
- **컴파일 타임 계산**: 배열 크기가 기계어 명령어에 하드코딩
- **직접 메모리 접근**: 베이스 주소 + 오프셋으로 즉시 계산
- **예측 가능한 성능**: 오버헤드 없음

### 동적 배열 (힙) - 수백~수천 CPU 사이클
```cpp
int* arr = new int[n];  // 런타임 크기 결정
```

**복잡한 처리 과정:**
- **시스템 콜**: `malloc()/new`는 커널에 메모리 요청
- **힙 관리**: 사용 가능한 메모리 블록 검색 및 분할
- **메타데이터 관리**: 할당 크기, 블록 연결 정보 저장
- **메모리 정렬**: 캐시 라인에 맞춰 주소 정렬
- **프래그멘테이션 처리**: 적절한 크기의 연속 메모리 찾기

## sizeof 연산자의 특성

### sizeof는 함수가 아닌 연산자
```cpp
sizeof(int)     // 연산자 사용법
sizeof int      // 괄호 선택적
```

**연산자인 증거:**
- **컴파일 타임 평가**: 컴파일 시점에 상수로 대체
- **런타임 오버헤드 없음**: 실행 시 함수 호출 발생하지 않음
- **괄호 선택적**: `sizeof int` 또는 `sizeof(int)` 둘 다 가능
- **타입에 직접 사용**: `sizeof(MyClass)` - 함수는 타입을 직접 인자로 받을 수 없음

### sizeof vs 일반 연산자
```cpp
// 일반 연산자
int result = x + y;    // 컴파일 → ADD 명령어로 변환 → 실행 시 CPU 계산

// sizeof 연산자
int size = sizeof(arr);  // 컴파일 → 상수 40으로 치환 → 실행 시 명령어 없음
```

**어셈블리 관점:**
```assembly
// sizeof 사용
mov eax, 40    ; 상수 40을 직접 로드, 실제 계산 없음
```

## 핵심 결론

1. **정적 배열**: 산술 연산 하나로 끝나는 단순함
2. **동적 배열**: 복잡한 메모리 관리 알고리즘 필요
3. **sizeof**: 컴파일러가 처리하는 메타 연산자로, 런타임에 명령어로 변환되지 않는 특수 연산자

**성능 차이의 본질**: 컴파일 타임 처리 vs 런타임 복잡한 알고리즘 수행