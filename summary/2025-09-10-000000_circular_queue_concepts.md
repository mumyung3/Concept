# C μ¤νƒ€μΌ λ°°μ—΄ ν™ν• ν κµ¬ν„ ν•µμ‹¬ κ°λ…

## 1. κΈ°λ³Έ κ°λ…

### C μ¤νƒ€μΌ λ°°μ—΄
- **λ°°μ—΄ μ΄λ¦„ = μ²« λ²μ§Έ μ”μ†μ μ£Όμ†**: `arr == &arr[0]`
- **λ°°μ—΄ μ ‘κ·Ό**: `arr[i]` = `*(arr + i)` (λ™μΌν• ν‘ν„)
- **sizeof μ°¨μ΄**: 
  - `sizeof(arr)`: μ „μ²΄ λ°°μ—΄ ν¬κΈ°
  - `sizeof(ptr)`: ν¬μΈν„° ν¬κΈ° (8λ°”μ΄νΈ in 64bit)
- **λ°°μ—΄μ€ μƒμ**: μ¬ν• λ‹Ή λ¶κ°€ (`arr = arr2` μ»΄νμΌ μ—λ¬)
  
  <details>
  <summary>π“ λ°°μ—΄μ΄ "μƒμ"μΈ μ΄μ  (ν΄λ¦­ν•μ—¬ νΌμΉκΈ°)</summary>
  
  #### 1. **λ°°μ—΄ μ΄λ¦„μ€ μ¬ν• λ‹Ή λ¶κ°€λ¥**
  ```cpp
  int arr1[5] = {1, 2, 3, 4, 5};
  int arr2[5] = {6, 7, 8, 9, 10};
  
  arr1 = arr2;  // β μ»΄νμΌ μ—λ¬!
  ```
  λ°°μ—΄ μ΄λ¦„ `arr1`μ€ λ©”λ¨λ¦¬μ κ³ μ •λ μ„μΉλ¥Ό κ°€λ¦¬ν‚¤λ©°, μ΄ μ„μΉλ” λ³€κ²½ν•  μ μ—†μµλ‹λ‹¤.
  
  #### 2. **ν¬μΈν„°μ™€μ μ°¨μ΄**
  - **ν¬μΈν„°**: λ³€μλ΅, λ‹¤λ¥Έ μ£Όμ†λ¥Ό κ°€λ¦¬ν‚¤λ„λ΅ λ³€κ²½ κ°€λ¥
  - **λ°°μ—΄ μ΄λ¦„**: μ»΄νμΌ μ‹μ μ— κ²°μ •λ κ³ μ • μ£Όμ†
  
  ```cpp
  int* ptr = arr1;  // OK
  ptr = arr2;       // OK - ν¬μΈν„°λ” μ¬ν• λ‹Ή κ°€λ¥
  arr1 = arr2;      // β - λ°°μ—΄ μ΄λ¦„μ€ μ¬ν• λ‹Ή λ¶κ°€
  ```
  
  #### 3. **"μƒμ"μ μ •ν™•ν• μλ―Έ**
  - λ°°μ—΄μ **μ”μ†**λ” λ³€κ²½ κ°€λ¥: `arr[0] = 100;` β…
  - λ°°μ—΄ **μ΄λ¦„μ΄ κ°€λ¦¬ν‚¤λ” μ£Όμ†**λ” λ³€κ²½ λ¶κ°€: `arr = λ‹¤λ¥Έμ£Όμ†;` β
  - μ¦‰, λ°°μ—΄ μ΄λ¦„μ€ "**μƒμ ν¬μΈν„°**"μ²λΌ λ™μ‘ (ν•μ§€λ§ μ§„μ§ ν¬μΈν„°λ” μ•„λ‹)
  
  #### 4. **μ»΄νμΌλ¬ κ΄€μ **
  - λ°°μ—΄ μ΄λ¦„μ€ **non-modifiable lvalue**
  - μ»΄νμΌ μ‹μ μ— μ¤νƒμ νΉμ • μ„μΉλ΅ κ³ μ •
  - `int arr[5]`λ” "arrμ΄λΌλ” μ΄λ¦„μΌλ΅ 20λ°”μ΄νΈ κ³µκ°„ ν™•λ³΄"λ¥Ό μλ―Έ
  - μ΄ κ³µκ°„μ μ‹μ‘ μ£Όμ†λ” ν”„λ΅κ·Έλ¨ μ‹¤ν–‰ μ¤‘ μ λ€ λ³€κ²½ λ¶κ°€
  
  #### 5. **μ¶”κ°€ νΉμ§•**
  - **νƒ€μ… μ •λ³΄ λ³΄μ΅΄**: `sizeof(arr)`λ” μ „μ²΄ λ°°μ—΄ ν¬κΈ° λ°ν™ (ν¬μΈν„°μ™€ λ‹¤λ¦„)
  - **&arrμ νƒ€μ…**: `int(*)[5]` (λ°°μ—΄ μ „μ²΄λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„°)
  - **ν•¨μ μΈμλ΅ μ „λ‹¬ μ‹**: ν¬μΈν„°λ΅ decayλμ–΄ μ „λ‹¬λ¨
  
  > π’΅ **ν•µμ‹¬**: λ°°μ—΄ μ΄λ¦„μ€ "κ·Έ μμ²΄κ°€ μ£Όμ†λ¥Ό λ‚νƒ€λ‚΄λ” μƒμ ν‘ν„μ‹"μ…λ‹λ‹¤. λ³€μκ°€ μ•„λ‹λΌ μ»΄νμΌ μ‹μ μ— κ²°μ •λλ” κ³ μ • μ£Όμ† λ μ΄λΈ”μ…λ‹λ‹¤.
  
  </details>
- **ν¬μΈν„°λ” λ³€μ**: μ¬ν• λ‹Ή κ°€λ¥ (`ptr = arr2` OK)

### ν¬μΈν„° μ‚°μ  μ—°μ‚°
```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;
ptr++;  // λ‹¤μ μ”μ†λ¥Ό κ°€λ¦¬ν‚΄ (4λ°”μ΄νΈ μ΄λ™)
*(ptr + 2)  // ptrλ΅λ¶€ν„° 2κ° λ’¤ μ”μ† μ ‘κ·Ό
```

## 2. ν™ν• νμ ν•µμ‹¬: λ¨λ“λ¬ μ—°μ‚°

### μΈλ±μ¤ μν™
```cpp
next_index = (current_index + 1) % SIZE;  // λ‹¤μ μΈλ±μ¤
prev_index = (current_index - 1 + SIZE) % SIZE;  // μ΄μ „ μΈλ±μ¤
```

### ν™ν• νΉμ„±
- λ°°μ—΄μ λμ—μ„ λ‹¤μ‹ μ²μμΌλ΅ μν™
- κ³ μ • ν¬κΈ° λ°°μ—΄μ κ³µκ°„μ„ μ¬μ‚¬μ©
- λ©”λ¨λ¦¬ ν¨μ¨μ μΈ ν κµ¬ν„

## 3. ν™ν• ν κµ¬μ΅°

### ν•µμ‹¬ λ©¤λ²„ λ³€μ
```cpp
struct CircularQueue {
    T* data;       // λ°μ΄ν„° λ°°μ—΄
    int capacity;  // μµλ€ ν¬κΈ°
    int front;     // μ²« λ²μ§Έ μ”μ† μΈλ±μ¤
    int rear;      // λ‹¤μ μ‚½μ… μ„μΉ μΈλ±μ¤
    int count;     // ν„μ¬ μ”μ† κ°μ
};
```

### frontμ™€ rearμ κ΄€κ³„
- **λΉ ν**: `count == 0` (frontμ™€ rear μ„μΉλ” λ¬΄κ΄€)
- **κ°€λ“ μ°¬ ν**: `count == capacity`
- **rear μ΄λ™**: `rear = (rear + 1) % capacity`
- **front μ΄λ™**: `front = (front + 1) % capacity`

## 4. μ£Όμ” μ—°μ‚°

### Enqueue (μ‚½μ…)
```cpp
bool enqueue(const T& value) {
    if(isFull()) return false;
    
    data[rear] = value;
    rear = (rear + 1) % capacity;  // ν™ν• μ¦κ°€
    count++;
    return true;
}
```

### Dequeue (μ κ±°)
```cpp
bool dequeue(T& value) {
    if(isEmpty()) return false;
    
    value = data[front];
    front = (front + 1) % capacity;  // ν™ν• μ¦κ°€
    count--;
    return true;
}
```

## 5. Full/Empty νλ³„ λ°©λ²•

### count λ³€μ μ‚¬μ© (κ¶μ¥)
- **μ¥μ **: λ…ν™•ν•κ³  κ°„λ‹¨ν• νλ³„
- **λ‹¨μ **: μ¶”κ°€ λ³€μ ν•„μ”
```cpp
bool isEmpty() { return count == 0; }
bool isFull() { return count == capacity; }
```

### front/rearλ§ μ‚¬μ©
- **λ¬Έμ μ **: front == rearμΌ λ• λΉ ν/κ°€λ“ μ°¬ ν κµ¬λ¶„ λ¶κ°€
- **ν•΄κ²°μ±…**: 
  1. ν• μΉΈ λΉ„μ›λ‘κΈ° (capacity-1κ°λ§ μ €μ¥)
  2. flag λ³€μ μ¶”κ°€ μ‚¬μ©

## 6. κµ¬ν„ μ‹ μ£Όμμ‚¬ν•­

### λ©”λ¨λ¦¬ κ΄€λ¦¬
- λ™μ  ν• λ‹Ή μ‹ μ†λ©Έμμ—μ„ λ°λ“μ‹ delete[]
- λ³µμ‚¬ μƒμ„±μμ™€ λ€μ… μ—°μ‚°μ κµ¬ν„ ν•„μ”
- ν…ν”λ¦Ώ μ‚¬μ© μ‹ memset λ€μ‹  κ°’ μ΄κΈ°ν™” μ‚¬μ©

### ν¬κΈ° μ΅°μ • (Resize)
```cpp
void resize(int newCapacity) {
    T* newData = new T[newCapacity];
    
    // μμ„λ€λ΅ λ³µμ‚¬
    int idx = front;
    for(int i = 0; i < count; i++) {
        newData[i] = data[idx];
        idx = (idx + 1) % capacity;
    }
    
    delete[] data;
    data = newData;
    front = 0;
    rear = count;
    capacity = newCapacity;
}
```

## 7. μ‹κ°„ λ³µμ΅λ„

| μ—°μ‚° | μ‹κ°„ λ³µμ΅λ„ |
|------|------------|
| Enqueue | O(1) |
| Dequeue | O(1) |
| Peek | O(1) |
| isEmpty/isFull | O(1) |
| Resize | O(n) |

## 8. ν™ν• νμ μ¥μ 

1. **κ³ μ • ν¬κΈ° λ©”λ¨λ¦¬**: μμΈ΅ κ°€λ¥ν• λ©”λ¨λ¦¬ μ‚¬μ©
2. **O(1) μ—°μ‚°**: λΉ λ¥Έ μ‚½μ…κ³Ό μ‚­μ 
3. **κ³µκ°„ μ¬μ‚¬μ©**: λ©”λ¨λ¦¬ ν¨μ¨μ„±
4. **κ°„λ‹¨ν• κµ¬ν„**: λ³µμ΅ν• ν¬μΈν„° μ—°μ‚° λ¶ν•„μ”

## 9. μ‹¤μ  ν™μ© μμ‹

- **λ²„νΌ κ΄€λ¦¬**: μƒμ‚°μ-μ†λΉ„μ ν¨ν„΄
- **μ΄λ²¤νΈ ν**: κ³ μ • ν¬κΈ° μ΄λ²¤νΈ μ²λ¦¬
- **νμ¤ν† λ¦¬ κ΄€λ¦¬**: μµκ·Ό Nκ° ν•­λ©λ§ μ μ§€
- **μ¤μΌ€μ¤„λ§**: λΌμ΄λ“ λ΅λΉ μ¤μΌ€μ¤„λ¬

## 10. μ¶”κ°€ ν•™μµ ν¬μΈνΈ

- **Thread-safe κµ¬ν„**: mutexλ¥Ό μ΄μ©ν• λ™κΈ°ν™”
- **Lock-free κµ¬ν„**: atomic μ—°μ‚° ν™μ©
- **Double-ended queue**: μ–‘λ°©ν–¥ μ‚½μ…/μ‚­μ 
- **Priority queue**: μ°μ„ μμ„ κΈ°λ° ν