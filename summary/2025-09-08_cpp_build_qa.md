# C++ 컴파일 및 빌드 과정 Q&A 정리
**작성일: 2025-09-08**

## 📌 핵심 개념 정리

### 1. 컴파일러와 라이브러리의 관계

**Q: 컴파일러를 설치하면 #include <iostream> 오류가 사라지는 이유는?**
- 컴파일러(g++) 설치 시 C++ 표준 라이브러리가 함께 설치됨
- 설치되는 것들:
  - 컴파일러: 코드를 기계어로 변환
  - 표준 라이브러리 헤더: `<iostream>`, `<vector>`, `<string>` 등
  - 런타임 라이브러리: 실행에 필요한 라이브러리 파일들

**Q: 운영체제만 설치하면 C++ 라이브러리가 있는 게 아니었나?**
- 운영체제: 기본 시스템 라이브러리만 포함
- C++ 개발 환경: 별도로 컴파일러 설치 필요
- 설치 순서: OS → 컴파일러(g++) → C++ 표준 라이브러리 자동 포함

### 2. 라이브러리의 형태

**Q: 라이브러리는 코드로 되어있나, 기계어로 되어있나?**
- **헤더 파일** (`<iostream>`): C++ 코드 (선언부만)
- **실제 구현체** (`.so`, `.a` 파일): 컴파일된 기계어
- 예시:
  ```cpp
  #include <iostream>  // 헤더는 코드 형태
  // 실제 구현은 /usr/lib/libstdc++.so에 기계어로 저장
  ```

### 3. VSCode와 컴파일러의 역할 분리

**Q: VSCode에서 오류를 잡는 주체는 누구?**
- **VSCode (IntelliSense)**: 실시간 오류 검사, 자동 완성
- **실제 동작**: 헤더 파일을 읽고 분석만 함 (컴파일 안 함)
- **컴파일러 (g++)**: 실제 빌드, 최적화, 실행 파일 생성

**Q: VSCode가 실제로 라이브러리를 탐색하나?**
- 네, 실제 파일 시스템을 직접 탐색
- `/usr/include/c++/11/iostream` 파일을 실제로 읽음
- 함수 선언, 클래스 정의를 파악해서 오류 검사

### 4. 컴파일러의 헤더 검색 경로

**Q: 헤더 파일 위치는 어떻게 찾나?**
```bash
# 컴파일러의 include 경로 확인
g++ -E -x c++ - -v < /dev/null
```
검색 순서:
1. `/usr/include/c++/11` - C++ 표준 라이브러리
2. `/usr/local/include` - 사용자 설치
3. `/usr/include` - 시스템 기본

### 5. 여러 컴파일러 관리

**Q: 여러 컴파일러가 있을 때 선택 방법은?**
1. **직접 지정**: `g++ main.cpp` 또는 `clang++ main.cpp`
2. **VSCode 설정**: `.vscode/c_cpp_properties.json`에서 compilerPath 지정
3. **시스템 기본값**: `update-alternatives --config c++`

**Q: 여러 컴파일러가 있어도 다른 컴파일러의 라이브러리는 인식 못하나?**
- 맞음. 선택된 컴파일러의 라이브러리만 인식
- g++ 사용 중이면 clang 전용 헤더는 못 찾음
- 해결: 수동으로 includePath 추가 필요

### 6. 컴파일과 링킹의 차이

**Q: Visual Studio에서 Include와 Library 경로를 따로 설정하는 이유?**
- **Include 경로** (컴파일 단계): 헤더 파일 (.h, .hpp) 찾기
- **Library 경로** (링킹 단계): 구현체 (.lib, .dll) 찾기

**Q: 컴파일은 되는데 링킹 오류가 발생할 수 있나?**
- 네, 가능함
- 헤더만 있으면 컴파일 성공
- 실제 라이브러리 없으면 링킹 실패
- 오류 메시지: "undefined reference to..."

### 7. 오류 검사 단계별 주체

**Q: 내가 작성한 cpp 파일의 오류는 누가 잡나?**
1. **코드 작성 중**: VSCode IntelliSense (빨간 줄)
2. **컴파일 시**: 컴파일러 (g++/clang++)
3. **링킹 시**: 링커 (ld)
4. **실행 중**: 운영체제/CPU (런타임 오류)

**Q: 라이브러리가 잘못된 코드라면 오류는 누가 잡나?**
- 컴파일된 라이브러리의 버그는 컴파일/링킹 시 못 잡음
- 실행 중에만 발견 (런타임 에러/크래시)
- 디버깅: gdb, 로그, 소스 코드 확인

### 8. 여러 cpp 파일 빌드 과정

**Q: 디렉토리의 여러 cpp 파일들은 어떻게 빌드되나?**
```bash
# 개별 컴파일
g++ -c main.cpp    → main.o
g++ -c math.cpp    → math.o

# 링킹
g++ main.o math.o -o program
```

**Q: main 외의 파일들은 왜 컴파일하나?**
- main이 사용하는 함수들이 다른 파일에 구현되어 있음
- 모든 구현체가 필요해서 함께 컴파일

**Q: source 폴더 아래 파일은 자동으로 빌드되나?**
- 기본적으로 수동 지정 필요
- 빌드 도구 사용 시 자동화:
  - CMake: `file(GLOB_RECURSE SOURCES "src/*.cpp")`
  - Makefile: `$(wildcard src/*.cpp)`
  - Visual Studio: 프로젝트에 추가된 파일 자동

**Q: VSCode가 자동으로 모든 cpp 빌드할 수 없나?**
- tasks.json 설정으로 가능
- `"${workspaceFolder}/*.cpp"` 패턴 사용
- 또는 Makefile/CMake 연동

## 📊 빌드 프로세스 요약

```
소스 코드(.cpp) → [컴파일] → 목적 파일(.o) → [링킹] → 실행 파일
                     ↑                           ↑
                헤더 파일(.h)              라이브러리(.lib/.so)
```

## 💡 핵심 포인트

1. **컴파일러 설치 = C++ 표준 라이브러리 포함**
2. **VSCode는 분석만, 실제 빌드는 컴파일러**
3. **헤더는 선언, 라이브러리는 구현**
4. **컴파일과 링킹은 별개 단계**
5. **여러 파일 빌드는 명시적 지정 또는 빌드 도구 사용**