# C++ Zero-Overhead Principle (제로 오버헤드 원칙)

## 핵심 철학
"You don't pay for what you don't use" - **사용하지 않는 기능에 대해 비용을 지불하지 않는다**
"What you do use, you couldn't hand code any better" - **사용하는 기능은 직접 구현해도 더 나은 성능을 낼 수 없다**

## 배열 크기 결정과 관련된 설계 선택

### 정적 배열 (스택)
- **컴파일 타임 크기 결정**: `int arr[100]`
- **성능**: 1~2 CPU 사이클로 할당
- **이유**: 스택 프레임 크기를 미리 계산, 메모리 레이아웃 확정
- **장점**: 예측 가능한 성능, 오버헤드 없음

### 동적 배열 (힙)
- **런타임 크기 결정**: `int* arr = new int[n]`
- **성능**: 수백~수천 CPU 사이클
- **사용 시기**: 런타임에 크기가 결정되어야 할 때만

## 다른 언어와의 비교

| 언어 | 접근 방식 | 트레이드오프 |
|------|----------|------------|
| C/C++ | 기본 정적, 선택적 동적 | 최고 성능, 수동 관리 |
| Java/Python | 모든 배열 동적 | 편리함, 성능 오버헤드 |
| Rust | 정적 + 안전성 검증 | 성능 + 메모리 안전성 |
| C99 VLA | 스택에서 가변 크기 | 유연함, 스택 오버플로우 위험 |

## 실제 영향

```cpp
// 빠른 코드 (스택)
void fast() {
    int arr[1000];  // 즉시 할당, 자동 해제
}

// 느린 코드 (힙)
void slow() {
    int* arr = new int[1000];  // 메모리 관리자 호출
    delete[] arr;               // 명시적 해제 필요
}
```

## 왜 여전히 유효한가?
1. **시스템 프로그래밍**: OS 커널, 디바이스 드라이버는 정확한 메모리 제어 필요
2. **고성능 컴퓨팅**: 게임 엔진, 금융 시스템은 마이크로초 단위 최적화 필요
3. **임베디드 시스템**: 제한된 리소스 환경에서 오버헤드 최소화 필수

## 핵심 교훈
C++는 "기본은 최대한 빠르게, 필요할 때만 유연하게"라는 철학으로 설계됨. 
프로그래머에게 선택권을 주되, 기본값은 항상 최고 성능을 지향한다.