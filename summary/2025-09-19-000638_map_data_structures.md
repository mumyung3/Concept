# Map과 자료구조 개념 정리

## 주요 학습 내용

### 1. Map의 정체
- **Map ≠ 새로운 기본 자료구조**
- **Map = 이진 트리의 응용/구현체**
- Red-Black Tree (자가 균형 이진 탐색 트리) 기반
- Key-Value 저장 기능을 추가한 고수준 자료구조

### 2. Map vs Unordered_Map
**std::map (이진 트리 기반):**
- O(log n) 접근 시간
- 항상 정렬됨
- Red-Black Tree 구현

**std::unordered_map (해시 테이블 기반):**
- O(1) 평균 접근 시간
- 정렬 안됨
- 해시 함수로 키 → 인덱스 변환 후 배열처럼 사용

### 3. 해시 함수의 특징
- **항상 숫자로만 변환** (임의 데이터 → 고정 크기 숫자)
- 해시 충돌시 체이닝(연결리스트) 또는 개방 주소법 사용
- unordered_map이 정렬 안되는 이유: 해시값이 원래 키 순서와 무관

### 4. 중복 키 정책
- **map, unordered_map**: 중복 키 불허 (Key의 유일성 보장)
- **multimap, unordered_multimap**: 중복 키 허용
- 중복 방지는 기술적 제약이 아닌 **Map의 설계 철학**

### 5. 자료구조 계층 구조
**기본 자료구조 → 응용 자료구조:**
- 배열 → vector, stack, queue
- 연결리스트 → list
- 이진트리 → map, set
- 해시테이블 → unordered_map

### 6. 성능 비교
| 자료구조 | 검색 | 삽입 | 삭제 | 정렬 |
|----------|------|------|------|------|
| std::map | O(log n) | O(log n) | O(log n) | ✅ |
| std::unordered_map | O(1) 평균 | O(1) 평균 | O(1) 평균 | ❌ |
| 배열 | O(n) | O(n) | O(n) | ❌ |

### 7. 트리 구현 방식
**포인터 기반 (일반적):**
- 메모리 효율적
- 동적 크기
- 삽입/삭제 유연

**배열 기반 (힙만 효율적):**
- 완전 이진 트리에서만 실용적
- 일반 트리는 메모리 낭비, 복잡성 증가

### 8. Red-Black Tree
- std::map의 내부 구현체
- 자가 균형 이진 탐색 트리
- 5가지 색상 규칙으로 균형 유지
- 최악의 경우에도 O(log n) 보장

## 핵심 깨달음
- **모든 복잡한 자료구조는 기본 자료구조의 조합**
- **기본 특성(시간복잡도, 메모리 구조)을 상속받음**
- **용도에 따른 적절한 자료구조 선택이 중요**

## 다음 학습 예정
1. Template 문법
2. TObjectPtr, TSharedPtr, TWeakPtr (Unreal Engine 스마트 포인터)